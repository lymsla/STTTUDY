/* type
- char은 내부적으로 정수(유니코드)로 저장 -> 정수형과 비슷+ 정수,실수형과 연산 가능 but boolean은 연산x
- boolean 빼고 다 서로 연산 가능하다
Boolean - 1byte /char - 2byte /byte-byte
int -4byte/ short - 2byte /long - 8byte - int는 대략 10자리수 까지
float - 4byte/ double - 8byte - double이 더 높은 정밀도를 보인다.

상수 - ex) 'final' int MAX_SPEED = 10 - 선언과 동시에 초기화 필수!!!!!
리터럴 - 값 _ 접미사(L,f,d)를 각 타입마다 붙여야함
-> 타입이 달라도 넓은 범위가 좁은 범위 포함 가능 ex) int i = 'a' / 더블 타입은 float타입에 저장 x  
문자열 리터럴에 덧셈연산자(+)를 사용시 - 다른 타입도 string type으로 바꿔줌 p.35

printf() 출력 형식을 지정 가능/ p.37 해결
-%f는 소숫점 6자리까지만 출력 - 나머지는 반올림
[
*/

/* 진법
bit, byte, word(cpu가 한번에 처리할 수 있는 크디 - 성능에 따라 달라짐 -32bit cpu, 64bit cpu)
2진수 -> 8,16진수 변환- 뒤에서 2의 제곱수만큼 끊어서 변환/ 10진수->n진수 변환 : 계속 나누고 반대로 나열하기
(소수 ver) 10진수 ->2진수 :10곱하기/ p.49참조
2의 보수 = 1의보수 +1

*/

/* 기본형 
boolean - 1byte / char : 유니코드를 저장
정수형 - int 가 기본
부호있는 정수의 오버플로우 : 부호비트가 0에서 1이 될때 발생
IEEE754 - S(1), E(8),M(23)/  E의 -127,128은 특별한 수를 표현하는데 사용 - why? -127~128, float 정밀도 7(소숫점 이하 6자리까지)
*/
/* 형변환
- 기본형의 형변화만 일단 다룸
정수형간의변환 - 큰 -> 작 : 값 손실/ 작->큰 : 빈 공간은 00으로 체움, 음수면111로 체움
실수형간의  변환 -구조는 동일 + 지수 변경chec p.77, float타입을 넘는 값을 float로 반환? -> (-)무한대 or (-)0으로 변환
정수형-실수형 변환
- 정수형->실수형 : 보통문제 없음 -> 다만 정밀도 문제 : ex) 인트의 최대값은 최대 10자리 but float는 7정밀도 : 문제 발생 가능
- 실수형 -> 정수형 : 소수점 버려짐
자동 형변환 - 큰->작은은 오류 발생
- 규칙 : 더 넓은 타입으로 변환된다

*/
