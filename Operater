/* 연산자
단항, 이항, 삼항 연산자

연산자의 우선순위 결합규칙
p.89만 확인
결합규칙 - 대부분 왼쪽 -> 오른 / but 단항, 대입연산자는 오른 ->왼 
p.91표에 총정리
산술변환 -(연산결과의 type은 피연산자와 같다 ex) int 5 / int 2 == int 2
*/

/* 단항 연산자
증감연산자 ++, -- (뒤에오면 참조 후 연산, 앞에오면 참조 전 연산)
ex) j = i++; / j = ++i; - 전자는 둘이 값이 다르다
*/

/* 산술연산자
피연산자가 실수형이면 0으로나눠도 오류 x-> 무한대
byte는 연산시 int형으로 변환 후 계산 -> byte+ byte = byte로 타입을 설정하면 오류-> casting 해줘야
p.100 - int * int에서 이미 overflow 발생하면 추후 casting해봤자 소용 없다. - 미리 casting해줘야

char 숫자를 int 숫자로 바꾸는 법 -> char '0'을 빼준다 - 유니코드를 이용한 방법

p.103 - 리터럴 연산 - 케스팅 할 필요 없다 -  코드 효율성 증가
나머지 연산자는 부호 무시한다!!!
*/

/* 비교연산자
- 대소비교 연산자 - 기본형(boolean제외) 사용 가능
- 등가비교 연산자 - 다 사용가능
비교 연산자도 연산시 형변환이 이뤄진다
실수형 비교는 근사값이므로 오차 발생 가능하다
p.12 질문?
문자열은 equal() 매서드 사용
*/

/* 논리연산자
&&가 ||보다 우선순위 높다1!!
단항연산자는 오른 -> 왼 p.120
*/

/* 비트연산자
정수 연산만 가능 p.121 recheck
~ : 1의 보수 연산자
>>쉬프트 연산자 - 피연산자의 자리를 움직임
x << n 은 x*2(n제곱)과 같다 / >>는 /2(n제곱)
쉬프트는 산술 연산자보다 속도가 빠르다 - but 가독성이 떨어짐 

*/

/* 기타 연산자
- 삼항 연산자 : 조건 연산자 ?
- 결합규칙 오른 -> 왼
- 산술변환 발생 - 타입 다를시
*/
